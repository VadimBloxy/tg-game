<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>JS MINECRAFT PC</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            color: white; transform: translate(-50%, -50%);
            pointer-events: none; font-size: 20px;
        }
        #info {
            position: absolute; top: 10px; left: 10px;
            color: white; background: rgba(0,0,0,0.5); padding: 10px;
        }
    </style>
</head>
<body>
    <div id="crosshair">+</div>
    <div id="info">Кликни по экрану, чтобы начать<br>WASD - Ходить | SPACE - Прыжок<br>ЛКМ - Сломать | Shift+ЛКМ - Поставить</div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

        // --- ИНИЦИАЛИЗАЦИЯ СЦЕНЫ ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- СВЕТ ---
        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 0.5).normalize();
        scene.add(directionalLight);

        // --- МИР (ГЕНЕРАЦИЯ БЛОКОВ) ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshLambertMaterial({ color: 0x55aa55 }); // Зеленый блок
        const blocks = [];

        for (let x = -10; x < 10; x++) {
            for (let z = -10; z < 10; z++) {
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(x, 0, z);
                scene.add(cube);
                blocks.push(cube);
            }
        }

        // --- УПРАВЛЕНИЕ КАМЕРОЙ ---
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();

        document.addEventListener('click', () => document.body.requestPointerLock());

        const onKeyDown = (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) velocity.y += 5; canJump = false; break;
            }
        };

        const onKeyUp = (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // Вращение мышкой
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        });

        // --- ВЗАИМОДЕЙСТВИЕ (БЛОКИ) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0); // Центр экрана

        document.addEventListener('mousedown', (e) => {
            if (document.pointerLockElement !== document.body) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(blocks);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                if (e.shiftKey) { // Ставим блок
                    const newBlock = new THREE.Mesh(geometry, material);
                    newBlock.position.copy(intersect.object.position).add(intersect.face.normal);
                    scene.add(newBlock);
                    blocks.push(newBlock);
                } else { // Ломаем блок
                    scene.remove(intersect.object);
                    blocks.splice(blocks.indexOf(intersect.object), 1);
                }
            }
        });

        camera.position.y = 2;
        camera.rotation.order = 'YXZ'; // Важно для корректного поворота головы

        // --- ИГРОВОЙ ЦИКЛ ---
        let prevTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (document.pointerLockElement === document.body) {
                // Гравитация и физика
                velocity.y -= 9.8 * delta; 
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                camera.translateX(-velocity.x * delta);
                camera.translateZ(velocity.z * delta);
                camera.position.y += velocity.y * delta;

                // Пол
                if (camera.position.y < 2) {
                    velocity.y = 0;
                    camera.position.y = 2;
                    canJump = true;
                }
            }

            renderer.render(scene, camera);
            prevTime = time;
        }
        animate();
    </script>
</body>
</html>
